/* 
  Принцип мемоизации на примере вычисления факториала
*/

// Объявляем массив, который будет служить хранилищем промежуточных значений 
let cache = []

/**
 * Принцип мемоизации на примере вычисления факториала
 * 
 * @param {*} n 
 */
function factorial(n) {
  // для начала ищем, есть ли уже такой результат в хранилище
  let isCacheNum = cache.find(x => x.num === n)

  if(isCacheNum) {
    // если такой результат есть, то мы возвращаем его без инициализации рекурсии
    return isCacheNum.res
  } else {
    // если нет, то вычисляем факториал посредством рекурсивного вызова и 
    // определяем некую модель элемента хранилища
    let cacheItem = {
      num: n,
      res: n ? n * factorial(n - 1) : 1
    }
  
    // если хранилище пустое, или аргумент функции больше, чем максимальный результат эл-тов хранилища, то 
    // перезаписываем его новыми значениями
    if(!cache.length || n > cache[cache.length - 1].num) cache.push(cacheItem)
    
    return cacheItem.res
  }
}

// Как итог - если вызвать функцию факториала, например, так:
factorial(50)
factorial(35)
// то в хранилище попадут все результаты вычислений от 1 до 50
// Аргумент второго вызова меньше первого, а значит, функция не будет вызывать рекурсию,
// а просто найдет такой результат в хранилище и вернет его, чем сэкономит память и 
// сократит время выполнения кода